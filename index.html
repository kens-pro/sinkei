<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9NZQDFD7DW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9NZQDFD7DW');
</script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üéµ „Åä„Å®„ÅÇ„Å¶„É°„É¢„É™„ÉºÔºÅ üéµ</title>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap" rel="stylesheet">
    <style>
        /* „ÉÜ„Éº„Éû„Ç´„É©„ÉºÂÆöÁæ© */
        :root {
            --bg-gradient-1: #ff9a9e;
            --bg-gradient-2: #fecfef;
            --bg-gradient-3: #a18cd1;
            
            --card-back-1: #ff9ff3;
            --card-back-2: #feca57;
            
            --card-front-bg: #ffffff;
            --text-color: #5f27cd;
            --accent-color: #ff6b81;
            
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(255, 255, 255, 0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Mochiy Pop One', sans-serif;
            background: linear-gradient(-45deg, var(--bg-gradient-1), var(--bg-gradient-2), var(--bg-gradient-2), var(--bg-gradient-3));
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
            overflow-y: auto;
            user-select: none;
            color: #333;
            background-image: 
                radial-gradient(white 15%, transparent 16%),
                radial-gradient(white 15%, transparent 16%);
            background-position: 0 0, 30px 30px;
            background-size: 60px 60px;
            background-blend-mode: overlay;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        h1 {
            font-size: 1.8em;
            color: #fff;
            text-shadow: 2px 2px 0 var(--text-color), 4px 4px 0 rgba(0,0,0,0.1);
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 0.05em;
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* „Ç≤„Éº„É†„Éú„Éº„Éâ„Ç≥„É≥„ÉÜ„Éä */
        .game-board-container {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            border-radius: 30px;
            padding: 20px;
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.15),
                inset 0 0 0 4px var(--glass-border);
            max-width: 600px;
            width: 100%;
            display: flex;
            justify-content: center;
            position: relative;
            margin-bottom: 15px;
        }

        .game-board {
            display: grid;
            gap: 10px;
            width: 100%;
            justify-content: center;
            position: relative;
        }

        /* „Ç∞„É™„ÉÉ„Éâ„É¨„Ç§„Ç¢„Ç¶„ÉàË™øÊï¥ */
        .game-board.level-1-grid { grid-template-columns: repeat(2, 1fr); max-width: 160px; }
        .game-board.level-2-grid { grid-template-columns: repeat(3, 1fr); max-width: 240px; }
        .game-board.level-3-grid { grid-template-columns: repeat(4, 1fr); max-width: 320px; }
        .game-board.level-4-grid { grid-template-columns: repeat(4, 1fr); max-width: 320px; }
        .game-board.level-5-grid { grid-template-columns: repeat(5, 1fr); max-width: 400px; }

        /* „Ç´„Éº„Éâ„Éá„Ç∂„Ç§„É≥ */
        .card {
            width: 100%;
            aspect-ratio: 1 / 1.2;
            position: relative;
            cursor: pointer;
            perspective: 1000px;
            max-width: 75px;
            justify-self: center;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s cubic-bezier(0.4, 2.5, 0.6, 0.8);
            transform-style: preserve-3d;
            border-radius: 15px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.1);
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        
        .card.matched {
            pointer-events: none;
            animation: popMatched 0.5s forwards;
        }
        .card.matched .card-inner {
            box-shadow: 0 0 15px var(--accent-color);
        }
        @keyframes popMatched {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            border: 3px solid #fff;
        }

        .card-back {
            background: linear-gradient(135deg, var(--card-back-1), var(--card-back-2));
        }
        .card-back::before {
            content: 'üéµ';
            font-size: 2em;
            color: #fff;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.2));
            animation: pulseIcon 2s infinite;
        }
        @keyframes pulseIcon {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .card-front {
            background: var(--card-front-bg);
            color: var(--text-color);
            transform: rotateY(180deg);
            font-size: 1.2em;
            font-weight: bold;
        }

        /* „ÉÅ„É•„Éº„Éà„É™„Ç¢„É´Áî®„ÅÆÊåá„Ç¢„Ç§„Ç≥„É≥„Å®Âº∑Ë™ø„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
        .tutorial-pointer {
            position: absolute;
            font-size: 3rem;
            pointer-events: none;
            z-index: 100;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.3));
            animation: tapGesture 1.5s infinite;
        }

        @keyframes tapGesture {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-5px, 5px) scale(0.9); }
            100% { transform: translate(0, 0) scale(1); }
        }

        .card.tutorial-target {
            animation: wiggleCard 1.5s infinite;
            z-index: 10;
        }
        .card.tutorial-target .card-inner {
            box-shadow: 0 0 15px #feca57;
            border: 2px solid #fff;
        }

        @keyframes wiggleCard {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        /* ÊÉÖÂ†±„Éë„Éç„É´ */
        .info-panel {
            background: #fff;
            border-radius: 20px;
            padding: 15px;
            width: 100%;
            max-width: 500px;
            box-shadow: 0 8px 0 rgba(0,0,0,0.05);
            text-align: center;
            margin-bottom: 15px;
            border: 4px solid #f0f0f0;
        }
        .info-panel p {
            margin: 5px 0;
            font-size: 1rem;
            color: #555;
        }
        #message {
            font-size: 1.1rem;
            color: var(--accent-color);
            min-height: 1.5em;
        }
        #timerDisplay, #currentLevelDisplay, #remainingPairs {
            color: #a29bfe;
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* „Éú„Çø„É≥ */
        .button-container {
            width: 100%;
            max-width: 400px;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        button {
            padding: 15px 30px;
            font-family: 'Mochiy Pop One', sans-serif;
            font-size: 1.3em;
            background: linear-gradient(to bottom, #7bed9f, #2ed573);
            color: #fff;
            border: 4px solid #fff;
            border-radius: 50px;
            cursor: pointer;
            width: 100%;
            box-shadow: 0 6px 0 #218c74, 0 10px 10px rgba(0,0,0,0.1);
            transition: all 0.1s;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.2);
        }
        button:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 #218c74, inset 0 2px 5px rgba(0,0,0,0.2);
        }

        /* „É©„É≥„Ç≠„É≥„Ç∞ */
        .ranking-section {
            background: rgba(255,255,255,0.9);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .ranking-section h2 {
            color: #fd79a8;
            font-size: 1.3em;
            margin-bottom: 10px;
            text-align: center;
        }
        #rankingTable {
            width: 100%;
            border-collapse: collapse;
        }
        #rankingTable th {
            color: #636e72;
            padding: 8px;
            border-bottom: 2px solid #dfe6e9;
        }
        #rankingTable td {
            padding: 10px;
            border-bottom: 1px solid #dfe6e9;
            color: #2d3436;
        }
        #rankingTable tr:nth-child(1) td { color: #d63031; font-weight: bold; }
        .rank-time { text-align: right; }

        .confetti-container {
            position: fixed;
            top:0; left:0; width:100%; height:100%;
            pointer-events:none; z-index:9999;
        }

        @media (max-width: 400px) {
            h1 { font-size: 1.5em; }
            .game-board-container { padding: 15px; }
            .card { max-width: 60px; }
            .card-back::before { font-size: 1.5em; }
            .game-board { gap: 8px; }
            .game-board.level-3-grid { grid-template-columns: repeat(3, 1fr); max-width: 200px; } 
            .game-board.level-4-grid { grid-template-columns: repeat(4, 1fr); max-width: 260px; }
            .game-board.level-5-grid { grid-template-columns: repeat(4, 1fr); max-width: 260px; }
        }
    </style>
</head>
<body>
    <h1>üéµ „Åä„Å®„ÅÇ„Å¶<br>„É°„É¢„É™„ÉºÔºÅ üéµ</h1>
    
    <div class="game-board-container">
        <div class="game-board" id="gameBoard"></div>
    </div>

    <div class="info-panel">
        <p>„É¨„Éô„É´: <span id="currentLevelDisplay">1</span> / „ÅÆ„Åì„Çä: <span id="remainingPairs"></span> „Éö„Ç¢</p>
        <p id="message"></p>
        <p>„Çø„Ç§„É†: <span id="timerDisplay">0.00</span> Áßí</p>
    </div>

    <div class="button-container">
        <button id="resetButton">„Åï„ÅÑ„Åó„Çá„Åã„ÇâÔºÅ</button>
    </div>

    <div class="ranking-section">
        <h2 id="rankingTitle">üèÜ „É©„É≥„Ç≠„É≥„Ç∞ (Lv.1) üèÜ</h2>
        <table id="rankingTable"></table>
    </div>

    <div id="confettiContainer" class="confetti-container"></div>

    <script>
        // Web Audio API„ÅÆÂàùÊúüÂåñ
        let audioContext;
        let masterGain;

        function recreateAudioGraph() {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            audioContext = new Ctx();
            masterGain = audioContext.createGain();
            masterGain.gain.value = 1;
            masterGain.connect(audioContext.destination);
        }

        recreateAudioGraph();

        async function resumeAudioContextIfNeeded() {
            if (!audioContext) recreateAudioGraph();
            if (audioContext.state === 'suspended' || audioContext.state === 'interrupted') {
                try { await audioContext.resume(); } catch (e) {}
            } else if (audioContext.state === 'closed') {
                recreateAudioGraph();
                try { await audioContext.resume(); } catch (e) {}
            }
        }

        document.addEventListener('pointerdown', resumeAudioContextIfNeeded, { passive: true });
        document.addEventListener('touchstart', resumeAudioContextIfNeeded, { passive: true });
        document.addEventListener('visibilitychange', () => { if (!document.hidden) resumeAudioContextIfNeeded(); });
        window.addEventListener('pageshow', () => { resumeAudioContextIfNeeded(); });

        // Âë®Ê≥¢Êï∞Ë®≠ÂÆö
        const frequencies = {
            '„Éâ': 261.63, '„Éâ#': 277.18, '„É¨': 293.66, '„É¨#': 311.13,
            '„Éü': 329.63, '„Éï„Ç°': 349.23, '„Éï„Ç°#': 369.99, '„ÇΩ': 392.00,
            '„ÇΩ#': 415.30, '„É©': 440.00, '„É©#': 466.16, '„Ç∑': 493.88, 'È´ò„Éâ': 523.25
        };
        const chromaticScaleNames = ['„Éâ', '„Éâ#', '„É¨', '„É¨#', '„Éü', '„Éï„Ç°', '„Éï„Ç°#', '„ÇΩ', '„ÇΩ#', '„É©', '„É©#', '„Ç∑', 'È´ò„Éâ'];

        const levels = [
            { id: 1, name: '„Éâ„Å†„Åë', notes: ['„Éâ'], pairs: 1, gridClass: 'level-1-grid' },
            { id: 2, name: '„Éâ„É¨„Éü', notes: ['„Éâ', '„É¨', '„Éü'], pairs: 3, gridClass: 'level-2-grid' },
            { id: 3, name: '„Éâ„É¨„Éü„Éï„Ç°„ÇΩ', notes: ['„Éâ', '„É¨', '„Éü', '„Éï„Ç°', '„ÇΩ'], pairs: 5, gridClass: 'level-3-grid' },
            { id: 4, name: '„Éâ„É¨„Éü„Éï„Ç°„ÇΩ„É©„Ç∑„Éâ', notes: ['„Éâ', '„É¨', '„Éü', '„Éï„Ç°', '„ÇΩ', '„É©', '„Ç∑', 'È´ò„Éâ'], pairs: 8, gridClass: 'level-4-grid' },
            { id: 5, name: 'ÈªíÈçµ„Å®ÁôΩÈçµ', notes: chromaticScaleNames, pairs: 13, gridClass: 'level-5-grid' }
        ];

        async function playNote(noteName, duration = 0.5) {
            await resumeAudioContextIfNeeded();
            const frequency = frequencies[noteName];
            if (!frequency) return 0;
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            const gainNode = audioContext.createGain();
            const t0 = audioContext.currentTime;
            const t1 = t0 + duration;
            gainNode.gain.setValueAtTime(0, t0);
            gainNode.gain.linearRampToValueAtTime(0.5, t0 + 0.05);
            gainNode.gain.linearRampToValueAtTime(0.0001, t1 - 0.02);
            gainNode.gain.setValueAtTime(0, t1);
            oscillator.connect(gainNode);
            gainNode.connect(masterGain);
            oscillator.start(t0);
            oscillator.stop(t1);
            oscillator.onended = () => { try { oscillator.disconnect(gainNode); gainNode.disconnect(masterGain); } catch (e) {} };
            return duration;
        }

        async function playFanfareAsync() {
            await resumeAudioContextIfNeeded();
            const seq = [{note:'„Éâ',dur:0.2},{note:'„Éü',dur:0.2},{note:'„ÇΩ',dur:0.2},{note:'È´ò„Éâ',dur:0.4}];
            let t = audioContext.currentTime;
            seq.forEach(s => {
                const o = audioContext.createOscillator(); o.type = 'triangle';
                o.frequency.setValueAtTime(frequencies[s.note], t);
                const g = audioContext.createGain();
                g.gain.setValueAtTime(0, t);
                g.gain.linearRampToValueAtTime(0.7, t + 0.05);
                g.gain.linearRampToValueAtTime(0.0001, t + s.dur - 0.02);
                o.connect(g); g.connect(masterGain);
                o.start(t); o.stop(t + s.dur);
                t += s.dur;
            });
            const waitMs = Math.max(0, (t - audioContext.currentTime) * 1000 + 20);
            return new Promise(res => setTimeout(res, waitMs));
        }

        async function playGrandFanfareAsync() {
            await resumeAudioContextIfNeeded();
            const now = audioContext.currentTime;
            let maxScheduledTime = now;
            const playChord = (freqs, start, dur) => {
                freqs.forEach(f => {
                    const o = audioContext.createOscillator(); o.type = 'sawtooth';
                    o.frequency.setValueAtTime(f, start);
                    const g = audioContext.createGain();
                    g.gain.setValueAtTime(0, start);
                    g.gain.linearRampToValueAtTime(0.9, start + 0.05);
                    g.gain.linearRampToValueAtTime(0.0001, start + dur - 0.02);
                    o.connect(g); g.connect(masterGain);
                    o.start(start); o.stop(start + dur);
                });
                maxScheduledTime = Math.max(maxScheduledTime, start + dur);
            };
            playChord([frequencies['„Éâ'], frequencies['„Éü'], frequencies['„ÇΩ']], now, 0.5);
            playChord([frequencies['„ÇΩ'], frequencies['„Ç∑'], frequencies['„É¨']], now + 0.5, 0.5);
            playChord([frequencies['„Éâ'], frequencies['„Éü'], frequencies['„ÇΩ']], now + 1.0, 1.0);
            const waitMs = Math.max(0, (maxScheduledTime - audioContext.currentTime) * 1000 + 20);
            return new Promise(res => setTimeout(res, waitMs));
        }

        function fadeOutAllAudio(ms = 120) {
            if (!audioContext || audioContext.state === 'closed') return;
            const t = audioContext.currentTime;
            masterGain.gain.cancelScheduledValues(t);
            masterGain.gain.setValueAtTime(masterGain.gain.value, t);
            masterGain.gain.linearRampToValueAtTime(0.0001, t + ms / 1000);
            masterGain.gain.setValueAtTime(1, t + ms / 1000 + 0.02);
        }

        let isTransitioning = false;
        const gameBoard = document.getElementById('gameBoard');
        const remainingPairsDisplay = document.getElementById('remainingPairs');
        const messageDisplay = document.getElementById('message');
        const timerDisplay = document.getElementById('timerDisplay');
        const currentLevelDisplay = document.getElementById('currentLevelDisplay');
        const rankingTitle = document.getElementById('rankingTitle');
        const rankingTable = document.getElementById('rankingTable');
        const resetButton = document.getElementById('resetButton');
        const confettiContainer = document.getElementById('confettiContainer');
        let cards = [];
        let hasFlippedCard = false;
        let lockBoard = false;
        let firstCard, secondCard;
        let matchedPairs = 0;
        let totalPairs = 0;
        let currentLevelIndex = 0;
        let timerStarted = false;
        let startTime;
        let timerIntervalId;
        const RANKING_PREFIX = 'memoryGameRanking_level';
        const MAX_RANKING_ENTRIES = 5;
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const CONFETTI_COUNT = isMobile ? 40 : 100;

        function startTimer() {
            startTime = performance.now();
            clearInterval(timerIntervalId);
            timerIntervalId = setInterval(() => {
                const currentTime = performance.now();
                const elapsedSeconds = (currentTime - startTime) / 1000;
                timerDisplay.textContent = elapsedSeconds.toFixed(2);
            }, 100);
        }
        function stopTimer() {
            clearInterval(timerIntervalId);
            const endTime = performance.now();
            const elapsedSeconds = (endTime - startTime) / 1000;
            timerDisplay.textContent = elapsedSeconds.toFixed(2);
            return elapsedSeconds;
        }
        function getRanking(level) {
            const rankingJson = localStorage.getItem(RANKING_PREFIX + level);
            return rankingJson ? JSON.parse(rankingJson) : [];
        }
        function saveRanking(level, newTime, playerName) {
            const ranking = getRanking(level);
            ranking.push({ time: newTime, name: playerName });
            ranking.sort((a, b) => a.time - b.time);
            localStorage.setItem(RANKING_PREFIX + level, JSON.stringify(ranking.slice(0, MAX_RANKING_ENTRIES)));
        }
        function displayRanking(level) {
            const ranking = getRanking(level);
            rankingTitle.textContent = `üèÜ „É©„É≥„Ç≠„É≥„Ç∞ (Lv.${level}) üèÜ`;
            let rowsHtml = ranking.length === 0 ? '<tr><td colspan="3" style="text-align:center">„Åæ„Å†Ë®òÈå≤„Åå„Å™„ÅÑ„ÇàÔºÅ</td></tr>' : 
                ranking.map((entry, index) => `<tr><td>${index + 1}‰Ωç</td><td>${entry.name}</td><td class="rank-time">${entry.time.toFixed(2)} Áßí</td></tr>`).join('');
            rankingTable.innerHTML = `<thead><tr><th>È†Ü‰Ωç</th><th>ÂêçÂâç</th><th>„Çø„Ç§„É†</th></tr></thead><tbody>${rowsHtml}</tbody>`;
        }

        function showTutorialHint() {
            removeTutorialHint();
            if (cards.length < 2) return;
            let indices = [0, 1]; 
            indices.forEach((index, i) => {
                const card = cards[index];
                card.classList.add('tutorial-target');
                const pointer = document.createElement('div');
                pointer.textContent = 'üëÜ';
                pointer.classList.add('tutorial-pointer');
                card.appendChild(pointer);
                if (i === 1) pointer.style.animationDelay = '0.5s';
            });
        }

        function removeTutorialHint() {
            const pointers = document.querySelectorAll('.tutorial-pointer');
            pointers.forEach(p => p.remove());
            const targets = document.querySelectorAll('.tutorial-target');
            targets.forEach(t => t.classList.remove('tutorial-target'));
        }

        function initializeGame() {
            const t = audioContext.currentTime;
            masterGain.gain.cancelScheduledValues(t);
            masterGain.gain.setValueAtTime(1, t);

            const currentLevelConfig = levels[currentLevelIndex];
            currentLevelDisplay.textContent = currentLevelConfig.id;
            totalPairs = currentLevelConfig.pairs;
            matchedPairs = 0;
            remainingPairsDisplay.textContent = totalPairs;
            messageDisplay.innerHTML = '<span style="color:#ff6b81; font-weight:bold;">„Ç´„Éº„Éâ„Çí2„Åæ„ÅÑ „Çø„ÉÉ„Éó„Åó„Å¶„Å≠ÔºÅ</span>';
            timerDisplay.textContent = '0.00';
            clearInterval(timerIntervalId);
            timerStarted = false;
            confettiContainer.innerHTML = '';

            gameBoard.className = 'game-board ' + currentLevelConfig.gridClass;
            while(gameBoard.firstChild) gameBoard.removeChild(gameBoard.firstChild);

            const gameNotes = [...currentLevelConfig.notes, ...currentLevelConfig.notes].sort(() => Math.random() - 0.5);
            const fragment = document.createDocumentFragment();
            cards = [];

            gameNotes.forEach(note => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.dataset.note = note;
                cardElement.innerHTML = `<div class="card-inner"><div class="card-front"></div><div class="card-back"></div></div>`;
                cardElement.addEventListener('click', flipCard, { passive: true });
                cards.push(cardElement);
                fragment.appendChild(cardElement);
            });
            gameBoard.appendChild(fragment);
            
            resetBoard();
            isTransitioning = false;
            displayRanking(currentLevelConfig.id);

            // ‚òÖÂ§âÊõ¥ÁÇπ: „É¨„Éô„É´1„ÅÆÊôÇ„Å†„Åë„Éí„É≥„Éà„ÇíË°®Á§∫„Åô„Çã
            if (currentLevelIndex === 0) {
                setTimeout(showTutorialHint, 500);
            }
        }

        async function flipCard() {
            removeTutorialHint();
            if (isTransitioning) return;
            if (lockBoard) return;
            if (this === firstCard) return;
            
            if (!timerStarted) {
                startTimer();
                timerStarted = true;
                messageDisplay.textContent = `Lv.${levels[currentLevelIndex].id} „Çπ„Çø„Éº„ÉàÔºÅ`;
            }
            this.classList.add('flipped');
            playNote(this.dataset.note);
            if (!hasFlippedCard) {
                hasFlippedCard = true;
                firstCard = this;
                messageDisplay.textContent = '„ÇÇ„ÅÜ1„Åæ„ÅÑ „Åà„Çâ„Çì„Åß„Å≠ÔºÅ';
                return;
            }
            secondCard = this;
            lockBoard = true;
            checkForMatch();
        }

        function checkForMatch() {
            const isMatch = firstCard.dataset.note === secondCard.dataset.note;
            if (isMatch) {
                messageDisplay.textContent = '‚ú® „Åô„Åî„ÅÑÔºÅ„Åõ„ÅÑ„Åã„ÅÑÔºÅ ‚ú®';
                disableCards();
            } else {
                messageDisplay.textContent = '„ÅÇ„ÇåÔºü„Å°„Åå„ÅÜ„Åä„Å®„Å†„Çà';
                unflipCards();
            }
        }

        async function disableCards() {
            firstCard.removeEventListener('click', flipCard);
            secondCard.removeEventListener('click', flipCard);
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');
            firstCard.querySelector('.card-front').textContent = firstCard.dataset.note;
            secondCard.querySelector('.card-front').textContent = secondCard.dataset.note;
            matchedPairs++;
            remainingPairsDisplay.textContent = totalPairs - matchedPairs;
            resetBoard();
            if (matchedPairs === totalPairs) {
                const finalTime = stopTimer();
                const currentLevelId = levels[currentLevelIndex].id;
                isTransitioning = true;
                lockBoard = true;
                const fanfarePromise = (currentLevelIndex === levels.length - 1) ? playGrandFanfareAsync() : playFanfareAsync();
                messageDisplay.textContent = `Lv.${currentLevelId} „ÇØ„É™„Ç¢ÔºÅ„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ`;
                launchConfetti();
                await fanfarePromise;
                let playerName = prompt(`üéâ „ÇØ„É™„Ç¢„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ üéâ\nLv.${currentLevelId} „Çø„Ç§„É†: ${finalTime.toFixed(2)} Áßí\n„Å™„Åæ„Åà„Çí„Åä„Åó„Åà„Å¶„Å≠ÔºÅ`, "„Å™„Å™„Åó„Åï„Çì");
                if (!playerName || !playerName.trim()) playerName = "„Å™„Å™„Åó„Åï„Çì";
                saveRanking(currentLevelId, finalTime, playerName.trim().substring(0, 10));
                displayRanking(currentLevelId);
                currentLevelIndex++;
                if (currentLevelIndex < levels.length) {
                    messageDisplay.textContent = `„Å§„Åé„ÅØ Lv.${levels[currentLevelIndex].id} „Å†„ÇàÔºÅ`;
                    initializeGame();
                } else {
                    messageDisplay.textContent = 'üëë ÂÖ®„É¨„Éô„É´„ÇØ„É™„Ç¢ÔºÅ„Åô„Åî„Åô„Åé„ÇãÔºÅ üëë';
                    currentLevelIndex = 0;
                    isTransitioning = false;
                }
            }
        }

        function unflipCards() {
            setTimeout(() => {
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                resetBoard();
                messageDisplay.textContent = '„Ç´„Éº„Éâ„Çí„ÇÅ„Åè„Å£„Å¶„Å≠ÔºÅ';
            }, 1200);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        function launchConfetti() {
            const colors = ['#ff9ff3', '#feca57', '#ff6b81', '#48dbfb', '#1dd1a1'];
            confettiContainer.innerHTML = ''; 
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < CONFETTI_COUNT; i++) {
                const confetti = document.createElement('div');
                confetti.style.position = 'absolute';
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = confetti.style.width;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = -20 + 'px';
                confetti.style.borderRadius = '50%';
                confetti.animate([
                    { transform: `translate(0, 0) rotate(0deg)`, opacity: 1 },
                    { transform: `translate(${Math.random()*100 - 50}px, 100vh) rotate(${Math.random()*720}deg)`, opacity: 0 }
                ], { duration: Math.random() * 2000 + 2000, easing: 'cubic-bezier(0.25, 1, 0.5, 1)', fill: 'forwards' });
                fragment.appendChild(confetti);
            }
            confettiContainer.appendChild(fragment);
        }

        resetButton.addEventListener('click', () => { fadeOutAllAudio(120); currentLevelIndex = 0; initializeGame(); });
        initializeGame();
    </script>
</body>
</html>